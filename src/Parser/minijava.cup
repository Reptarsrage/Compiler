/*
 * CUP specification for the parser for a simple demo language.
 * Change this into the parser for your implementation of MiniJava.
 * CSE 401/P501 Au11.
 */

package Parser;

import AST.ASTNode;
import AST.ArrayAssign;
import AST.ArrayLength;
import AST.ArrayLookup;
import AST.Assign;
import AST.Block;
import AST.BooleanType;
import AST.Call;
import AST.ClassDecl;
import AST.ClassDeclExtends;
import AST.ClassDeclList;
import AST.ClassDeclSimple;
import AST.Comment;
import AST.ConstantExp;
import AST.Display;
import AST.Divide;
import AST.Equals;
import AST.Exp;
import AST.ExpList;
import AST.False;
import AST.Formal;
import AST.FormalList;
import AST.GreaterThan;
import AST.GreaterThanOrEqualTo;
import AST.Identifier;
import AST.IdentifierExp;
import AST.IdentifierType;
import AST.If;
import AST.IntArrayType;
import AST.IntegerLiteral;
import AST.IntegerType;
import AST.LessThan;
import AST.LessThanOrEqualTo;
import AST.MainClass;
import AST.MethodDecl;
import AST.MethodDeclList;
import AST.Minus;
import AST.Mod;
import AST.NewArray;
import AST.NewObject;
import AST.Not;
import AST.NotEqual;
import AST.Plus;
import AST.Print;
import AST.Program;
import AST.ShortCircuitAnd;
import AST.ShortCircuitOr;
import AST.Statement;
import AST.StatementList;
import AST.This;
import AST.Times;
import AST.True;
import AST.Type;
import AST.VarDecl;
import AST.VarDeclList;
import AST.While;
import java_cup.runtime.Symbol;

import java.util.LinkedList;
import java.util.List;

/* Code in the following section is included in the generated parser */

parser code {:
  /* Override default error message routine to handle line numbers correctly */
  /* This routine is also called in the process of handling fatal errors. */

  /** Report a non fatal error (or warning).  This method takes a message
   *  string and an additional object (to be used by specializations
   *  implemented in subclasses).  Prints the same simple error message
   *  as the base class version, but correctly labels the line number.
   *
   * @param message an error message.
   * @param info    an extra object reserved for use by specialized subclasses.
   */
  public void report_error(String message, Object info)
    {
      System.err.print(message);
      System.err.flush();
      if (info instanceof Symbol) {
        if (((Symbol)info).left != -1) {
          System.err.println(" at line " + ((Symbol)info).left +
                             " of input");
        } else {
          System.err.println("");
        }
      } else {
        System.err.println("");
      }
    }
:};

/* end of code included in generated parser

/* Terminals (tokens returned by the scanner) */

/* reserved words: */
terminal PUBLIC;
terminal STATIC;
terminal CLASS;
terminal THIS;
terminal TRUE;
terminal FALSE;
terminal NEW;
terminal INT;
terminal DOUBLE;
terminal BOOLEAN;
terminal STRING;
terminal DISPLAY;
terminal PRINTLN;
terminal RETURN;
terminal EXTENDS;
terminal COMMENT;
terminal IF;
terminal ELSE;
terminal WHILE;
terminal VOID;
terminal LENGTH;

/* operators: */
terminal AND, OR, EQ, NOTEQ, LESSEQ, GREATEREQ, LESS, GREATER, PLUS, MINUS, MULT, DIV, MOD, BECOMES, NOT;

/* delimiters: */
terminal LCURLYBRACE, RCURLYBRACE, LBRACKET, RBRACKET, LPAREN, RPAREN, SEMICOLON, DOT, COMMA;

/* tokens with values: */
terminal String IDENTIFIER;
terminal String CONSTANT;
terminal String D_CONSTANT;

/* Nonterminals */
nonterminal MainClass MainClass;
nonterminal ClassDecl ClassDeclaration;
nonterminal ClassDeclList ClassDeclarationList;
nonterminal VarDecl VarDeclaration;
nonterminal VarDeclList VariableDeclarationList;
nonterminal MethodDecl MethodDeclaration;
nonterminal MethodDeclList MethodDeclarationList;
nonterminal FormalList FormalList;
nonterminal Type Type;
nonterminal Statement Statement;
nonterminal StatementList StatementList;
nonterminal Assign AssignStatement;
nonterminal Display DisplayStatement;
nonterminal ArrayAssign ArrayAssignStatement;
nonterminal While WhileStatement;
nonterminal Print PrintStatement;
nonterminal Comment CommentLine;
nonterminal If IfElseStatement;
nonterminal Exp Expression;
nonterminal ExpList ExpressionList;
nonterminal Identifier Identifier;

nonterminal List<Statement> Program;


/* Precedence declarations */
// source for these are http://en.cppreference.com/w/cpp/language/operator_precedence
precedence left COMMA;
precedence right BECOMES;
precedence left OR;
precedence left AND;
precedence left EQ, NOTEQ;
precedence left LESSEQ, GREATEREQ, LESS, GREATER;
precedence left PLUS, MINUS;
precedence left MULT, DIV, MOD;
precedence right NOT, NEW;
precedence left DOT, LPAREN, LBRACKET;


/* Productions */

Program ::=
          Statement:s
            {:
              List<Statement> p = new LinkedList<Statement>();
              p.add(s);
              RESULT = p;
            :}
        | Program:p Statement:s
            {:
              p.add(s);
              RESULT = p;
            :}
        ;

Statement   ::=
		IfElseStatement:s
		    {: RESULT = s; :}
		| WhileStatement:s
			{: RESULT = s; :}
		| PrintStatement:s
			{: RESULT = s; :}
        | DisplayStatement:s
            {: RESULT = s; :}
		| AssignStatement:s
            {: RESULT = s; :}
		| ArrayAssignStatement:s
			{: RESULT = s; :}
		| CommentLine:s
            {: RESULT = s; :}
        ;		

ArrayAssignStatement ::=
          Identifier:id LBRACKET Expression:exp1 RBRACKET BECOMES Expression:exp2 SEMICOLON
            {: RESULT = new ArrayAssign(id, exp1, exp2, idleft); :}
        ;
		
AssignStatement ::=
          Identifier:id BECOMES Expression:expr SEMICOLON
            {: RESULT = new Assign(id, expr, idleft); :}
        ;

Identifier  ::=
          IDENTIFIER:id
            {: RESULT = new Identifier(id, idleft); :}
        ;
		
Type  ::=
		INT:i LBRACKET RBRACKET
		   {: RESULT = new IntArrayType(ileft); :}
		
		| BOOLEAN:b
		   {: RESULT = new BooleanType(bleft); :}
		
		| INT:i
		   {: RESULT = new IntegerType(ileft); :}
		
		| Identifier:id
		   {: RESULT = new IdentifierType(id.toString(), idleft); :}
		;

VarDeclaration ::=
          Type:t Identifier:id SEMICOLON
             {: RESULT = new VarDecl(t, id, tleft); :}
        ;

MethodDeclaration ::=
		  PUBLIC:p Type:t Identifier:i LPAREN FormalList:flist RPAREN 
		  LCURLYBRACE VariableDeclarationList:vdlist StatementList:slist RETURN
		  Expression:expr SEMICOLON RCURLYBRACE
			{: RESULT = new MethodDecl(t, i, flist, vdlist, slist, expr, pleft); :}
		;
		
DisplayStatement ::=
          DISPLAY:d Expression:expr SEMICOLON
             {: RESULT = new Display(expr, dleft); :}
        ;
PrintStatement ::=
		  PRINTLN:p LPAREN Expression:exp RPAREN SEMICOLON
		     {: RESULT = new Print(exp, pleft); :}
		;
WhileStatement ::=
		  WHILE:w LPAREN Expression:exp RPAREN Statement:s
		     {: RESULT = new While(exp, s, wleft); :}
		;
		
CommentLine ::=
          COMMENT:c
             {: RESULT = new Comment(cleft); :}
        ;
IfElseStatement ::=
		  IF:i LPAREN Expression:e RPAREN Statement:s1 ELSE Statement:s2
		     {: RESULT = new If(e, s1, s2, ileft); :}
		;
			
Expression    ::=
        Expression:arg1 AND Expression:arg2
            {: RESULT = new ShortCircuitAnd(arg1, arg2, arg1left); :}
		
		| Expression:arg1 OR Expression:arg2
            {: RESULT = new ShortCircuitOr(arg1, arg2, arg1left); :}
		
		| Expression:arg1 EQ Expression:arg2
            {: RESULT = new Equals(arg1, arg2, arg1left); :}
		
		| Expression:arg1 NOTEQ Expression:arg2
            {: RESULT = new NotEqual(arg1, arg2, arg1left); :}
		
		| Expression:arg1 LESSEQ Expression:arg2
            {: RESULT = new LessThanOrEqualTo(arg1, arg2, arg1left); :}
		
		| Expression:arg1 GREATEREQ Expression:arg2
            {: RESULT = new GreaterThanOrEqualTo(arg1, arg2, arg1left); :}
		
		| Expression:arg1 LESS Expression:arg2
            {: RESULT = new LessThan(arg1, arg2, arg1left); :}
		
		| Expression:arg1 GREATER Expression:arg2
            {: RESULT = new GreaterThan(arg1, arg2, arg1left); :}			
        
		| Expression:arg1 PLUS Expression:arg2
            {: RESULT = new Plus(arg1, arg2, arg1left); :}
		
		| Expression:arg1 MINUS Expression:arg2
            {: RESULT = new Minus(arg1, arg2, arg1left); :}
		
		| Expression:arg1 MULT Expression:arg2
            {: RESULT = new Times(arg1, arg2, arg1left); :}
		
		| Expression:arg1 DIV Expression:arg2
            {: RESULT = new Divide(arg1, arg2, arg1left); :}

		| Expression:arg1 MOD Expression:arg2
            {: RESULT = new Mod(arg1, arg2, arg1left); :}
		  
		| Expression:arg1 LBRACKET Expression:arg2 RBRACKET
            {: RESULT = new ArrayLookup(arg1, arg2, arg1left); :}
	
		| Expression:arg1 DOT LENGTH
            {: RESULT = new ArrayLength(arg1, arg1left); :}
  
		| Expression:arg1 DOT IDENTIFIER:name LPAREN ExpressionList:explist RPAREN
            {: Identifier id = new Identifier(name, nameleft);
			RESULT = new Call(arg1, id, explist, arg1left); :}
		
		| Expression:arg1 DOT IDENTIFIER:name LPAREN RPAREN
            {:  ExpList list = new ExpList(arg1left);
				Identifier id = new Identifier(name, nameleft);
				RESULT = new Call(arg1, id, list, arg1left); :}
	
        | CONSTANT:value
            {: RESULT = new ConstantExp(value, valueleft); :}
			
        | TRUE:t
            {: RESULT = new True(tleft); :}
		
		| FALSE:f
            {: RESULT = new False(fleft); :}
			
		|  IDENTIFIER:name
            {: RESULT = new IdentifierExp(name, nameleft); :}

		| THIS:t
            {: RESULT = new This(tleft); :}
		
		| NEW:n INT LBRACKET Expression:exp RBRACKET
            {: RESULT = new NewArray(exp, nleft); :}
			
		| NEW:n Identifier:name LPAREN RPAREN
            {: RESULT = new NewObject(name, nleft); :}
				
		| NOT:n Expression:expr
            {: RESULT = new Not(expr, nleft); :}
		
		| LPAREN Expression:expr RPAREN
            {: RESULT = expr; :}
        ;

ExpressionList ::=
		  Expression:f1
             {: ExpList list = new ExpList(f1left); 
			    list.add(f1); 
				RESULT = list; :}
		  ExpressionList:list COMMA Expression:exp
             {: list.add(exp);
				RESULT = list; :}
        ;
FormalList ::= FormalList:list {: RESULT = list; :}; //TODO
MethodDeclarationList ::= MethodDeclarationList:list {: RESULT = list; :}; //TODO
ClassDeclarationList ::= ClassDeclarationList:list {: RESULT = list; :}; //TODO
VariableDeclarationList ::= VariableDeclarationList:list {: RESULT = list; :}; //TODO
StatementList ::= StatementList:list {: RESULT = list; :}; //TODO
