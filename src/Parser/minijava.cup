/*
 * CUP specification for the parser for a simple demo language.
 * Change this into the parser for your implementation of MiniJava.
 * CSE 401/P501 Au11.
 */

package Parser;

import AST.ASTNode;
import AST.ArrayAssign;
import AST.ArrayLength;
import AST.ArrayLookup;
import AST.Assign;
import AST.Block;
import AST.BooleanType;
import AST.Call;
import AST.ClassDecl;
import AST.ClassDeclExtends;
import AST.ClassDeclList;
import AST.ClassDeclSimple;
import AST.ConstantExp;
import AST.Display;
import AST.Divide;
import AST.Equals;
import AST.Exp;
import AST.ExpList;
import AST.False;
import AST.Formal;
import AST.FormalList;
import AST.GreaterThan;
import AST.GreaterThanOrEqualTo;
import AST.Identifier;
import AST.IdentifierExp;
import AST.IdentifierType;
import AST.If;
import AST.IntArrayType;
import AST.IntegerLiteral;
import AST.IntegerType;
import AST.LessThan;
import AST.LessThanOrEqualTo;
import AST.MainClass;
import AST.MethodDecl;
import AST.MethodDeclList;
import AST.Minus;
import AST.Mod;
import AST.NewArray;
import AST.NewObject;
import AST.Not;
import AST.Plus;
import AST.Print;
import AST.Program;
import AST.ShortCircuitAnd;
import AST.ShortCircuitOr;
import AST.Statement;
import AST.StatementList;
import AST.This;
import AST.Times;
import AST.True;
import AST.Type;
import AST.VarDecl;
import AST.VarDeclList;
import AST.While;
import java_cup.runtime.Symbol;

import java.util.LinkedList;
import java.util.List;

/* Code in the following section is included in the generated parser */

parser code {:
  /* Override default error message routine to handle line numbers correctly */
  /* This routine is also called in the process of handling fatal errors. */

  /** Report a non fatal error (or warning).  This method takes a message
   *  string and an additional object (to be used by specializations
   *  implemented in subclasses).  Prints the same simple error message
   *  as the base class version, but correctly labels the line number.
   *
   * @param message an error message.
   * @param info    an extra object reserved for use by specialized subclasses.
   */
  public void report_error(String message, Object info)
    {
      System.err.print(message);
      System.err.flush();
      if (info instanceof Symbol) {
        if (((Symbol)info).left != -1) {
          System.err.println(" at line " + ((Symbol)info).left +
                             " of input");
        } else {
          System.err.println("");
        }
      } else {
        System.err.println("");
      }
    }
:};

/* end of code included in generated parser

/* Terminals (tokens returned by the scanner) */

/* reserved words: */
terminal PUBLIC;
terminal STATIC;
terminal CLASS;
terminal THIS;
terminal TRUE;
terminal FALSE;
terminal NEW;
terminal INT;
terminal DOUBLE;
terminal BOOLEAN;
terminal STRING;
terminal DISPLAY;
terminal PRINTLN;
terminal RETURN;
terminal EXTENDS;
terminal COMMENT;
terminal IF;
terminal ELSE;
terminal WHILE;
terminal VOID;
terminal LENGTH;

/* operators: */
terminal AND, OR, EQ, LESSEQ, GREATEREQ, LESS, GREATER, PLUS, MINUS, MULT, DIV, MOD, BECOMES, NOT;

/* delimiters: */
terminal LCURLYBRACE, RCURLYBRACE, LBRACKET, RBRACKET, LPAREN, RPAREN, SEMICOLON, DOT, COMMA;

/* tokens with values: */
terminal String IDENTIFIER;
terminal String CONSTANT;
terminal String D_CONSTANT;

/* Nonterminals */

nonterminal List<Statement> Program;
nonterminal Statement Statement;
nonterminal Assign AssignStatement;
nonterminal Display DisplayStatement;
nonterminal Exp Expression;
nonterminal Identifier Identifier;


/* Precedence declarations */

precedence nonassoc AND, OR, EQ, LESSEQ, GREATEREQ, LESS, GREATER;
precedence left PLUS, MINUS;
precedence left MULT, DIV, MOD;


/* Productions */

Program ::=
          Statement:s
            {:
              List<Statement> p = new LinkedList<Statement>();
              p.add(s);
              RESULT = p;
            :}
        | Program:p Statement:s
            {:
              p.add(s);
              RESULT = p;
            :}
        ;

Statement   ::=
          AssignStatement:s
            {: RESULT = s; :}
        | DisplayStatement:s
            {: RESULT = s; :}
        ;

AssignStatement ::=
          Identifier:id BECOMES Expression:expr SEMICOLON
            {: RESULT = new Assign(id, expr, idleft); :}
        ;

Identifier  ::=
          IDENTIFIER:id
            {: RESULT = new Identifier(id, idleft); :}
        ;

DisplayStatement ::=
          DISPLAY:d Expression:expr SEMICOLON
             {: RESULT = new Display(expr, dleft); :}
        ;

Expression    ::=
          IDENTIFIER:name
            {: RESULT = new IdentifierExp(name, nameleft); :}

        | CONSTANT:value
            {: RESULT = new ConstantExp(value, valueleft); :}
  
		| Expression:arg1 AND Expression:arg2
            {: RESULT = new ShortCircuitAnd(arg1, arg2, arg1left); :}
		
		| Expression:arg1 OR Expression:arg2
            {: RESULT = new ShortCircuitOr(arg1, arg2, arg1left); :}
		
		| Expression:arg1 EQ Expression:arg2
            {: RESULT = new Equals(arg1, arg2, arg1left); :}
		
		| Expression:arg1 LESSEQ Expression:arg2
            {: RESULT = new LessThanOrEqualTo(arg1, arg2, arg1left); :}
		
		| Expression:arg1 GREATEREQ Expression:arg2
            {: RESULT = new GreaterThanOrEqualTo(arg1, arg2, arg1left); :}
		
		| Expression:arg1 LESS Expression:arg2
            {: RESULT = new LessThan(arg1, arg2, arg1left); :}
		
		| Expression:arg1 GREATER Expression:arg2
            {: RESULT = new GreaterThan(arg1, arg2, arg1left); :}			
        
		| Expression:arg1 PLUS Expression:arg2
            {: RESULT = new Plus(arg1, arg2, arg1left); :}
		
		| Expression:arg1 MINUS Expression:arg2
            {: RESULT = new Minus(arg1, arg2, arg1left); :}
		
		| Expression:arg1 MULT Expression:arg2
            {: RESULT = new Times(arg1, arg2, arg1left); :}
		
		| Expression:arg1 DIV Expression:arg2
            {: RESULT = new Divide(arg1, arg2, arg1left); :}

		| Expression:arg1 MOD Expression:arg2
            {: RESULT = new Mod(arg1, arg2, arg1left); :}
			
        | LPAREN Expression:expr RPAREN
            {: RESULT = expr; :}
        ;
